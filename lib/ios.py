#!/usr/bin/env python
# -*- coding: utf-8 -*-

# CAVEAT UTILITOR
#
# This file was automatically generated by Grako.
#
#    https://pypi.python.org/pypi/grako/
#
# Any changes you make to it will be overwritten the next time
# the file is generated.


from __future__ import print_function, division, absolute_import, unicode_literals
from grako.parsing import graken, Parser


__version__ = (2015, 1, 19, 12, 45, 51, 0)

__all__ = [
    'iosParser',
    'iosSemantics',
    'main'
]


class iosParser(Parser):
    def __init__(self, whitespace=None, nameguard=True, **kwargs):
        super(iosParser, self).__init__(
            whitespace=whitespace,
            nameguard=nameguard,
            **kwargs
        )

    @graken()
    def _ip4_(self):
        self._pattern(r'((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])')

    @graken()
    def _ipX_(self):
        self._pattern(r'\w+\.\w+\.\w+\.\w+')

    @graken()
    def _ip6_(self):
        self._pattern(r'[a-fA-F0-9]*:[a-fA-F0-9\.\:]+')

    @graken()
    def _NL_(self):
        self._token('\n')

    @graken()
    def _TOEOL_(self):
        self._pattern(r'[^\n]*')

    @graken()
    def _identifier_(self):
        self._pattern(r'[a-zA-Z_][A-Za-z0-9_\-\.]*')

    @graken()
    def _int_(self):
        self._pattern(r'[0-9]+')

    @graken()
    def _string_(self):
        self._pattern(r'[\S]+')

    @graken()
    def _obj_name_(self):
        self._pattern(r'[A-Za-z0-9_\-\.]*')

    @graken()
    def _hostname_(self):
        self._token('hostname')
        self._identifier_()
        self.ast['hostname'] = self.last_node
        self._NL_()

        self.ast._define(
            ['hostname'],
            []
        )

    @graken()
    def _domain_name_(self):
        self._token('domain-name')
        self._identifier_()
        self.ast['domain_name'] = self.last_node

        self.ast._define(
            ['domain_name'],
            []
        )

    @graken()
    def _description_(self):
        with self._choice():
            with self._option():
                self._token('description')
                self._pattern(r'[^\n]+')
                self.ast['description'] = self.last_node
                self._NL_()
            with self._option():
                pass
            self._error('no available options')

        self.ast._define(
            ['description'],
            []
        )

    @graken()
    def _interface_(self):
        self._token('interface')
        self._interface_alias_()
        self.ast['alias'] = self.last_node
        self._NL_()

        def block2():
            self._interface_detail_()
        self._closure(block2)
        self.ast['detail'] = self.last_node
        self._token('!')
        self._NL_()

        self.ast._define(
            ['alias', 'detail'],
            []
        )

    @graken()
    def _interface_alias_(self):
        self._pattern(r'[^\s]+')

    @graken()
    def _interface_detail_(self):
        with self._choice():
            with self._option():
                self._token('nameif')
                self.ast['type'] = self.last_node
                self._identifier_()
                self.ast['name'] = self.last_node
                self._NL_()
            with self._option():
                self._token('description')
                self.ast['type'] = self.last_node
                self._pattern(r'[^\n]+')
                self.ast['description'] = self.last_node
                self._NL_()
            with self._option():
                self._token('ip nat')
                self.ast['type'] = self.last_node
                self._obj_name_()
                self.ast['name'] = self.last_node
                self._NL_()
            with self._option():
                self._token('no ip address')
                self._pattern(r'[^!]*')
                self._token('!')
                self._NL_()
            with self._option():
                self._token('encryption mode')
                self._pattern(r'[^!]*')
                self._token('!')
                self._NL_()
            with self._option():
                self._token('ssid')
                self._pattern(r'[^!]*')
                self._token('!')
                self._NL_()
            with self._option():
                self._pattern(r'[^(^!|\n)]*')
                self._NL_()
            with self._option():
                pass
            self._error('no available options')

        self.ast._define(
            ['type', 'name', 'description'],
            []
        )

    @graken()
    def _acl_id_(self):
        self._obj_name_()

    @graken()
    def _acl_line_(self):
        with self._choice():
            with self._option():
                self._token('line')
                self._int_()
            with self._option():
                pass
            self._error('no available options')

    @graken()
    def _acl_extended_(self):
        self._token('extended')

    @graken()
    def _acl_mode_(self):
        with self._group():
            with self._choice():
                with self._option():
                    self._token('permit')
                with self._option():
                    self._token('deny')
                self._error('expecting one of: deny permit')

    @graken()
    def _acl_protocol_(self):
        with self._choice():
            with self._option():
                self._token('object-group')
                self.ast['type'] = self.last_node
                with self._group():
                    with self._choice():
                        with self._option():
                            self._acl_object_group_service_id_()
                        with self._option():
                            self._acl_object_group_protocol_id_()
                        self._error('no available options')
                self.ast['name'] = self.last_node
            with self._option():
                self._token('object')
                self.ast['type'] = self.last_node
                self._acl_object_service_id_()
                self.ast['name'] = self.last_node
            with self._option():
                with self._group():
                    with self._choice():
                        with self._option():
                            self._protocol_code_()
                        with self._option():
                            self._int_()
                        self._error('no available options')
                self.ast['name'] = self.last_node
            self._error('no available options')

        self.ast._define(
            ['type', 'name'],
            []
        )

    @graken()
    def _node_(self):
        self._acl_host_()
        self.ast['host'] = self.last_node
        with self._optional():
            self._acl_port_()
            self.ast['port'] = self.last_node

        self.ast._define(
            ['host', 'port'],
            []
        )

    @graken()
    def _acl_object_group_network_id_(self):
        with self._ifnot():
            pass

    @graken()
    def _acl_object_network_id_(self):
        with self._ifnot():
            pass

    @graken()
    def _acl_object_group_service_id_(self):
        with self._ifnot():
            pass

    @graken()
    def _acl_object_service_id_(self):
        with self._ifnot():
            pass

    @graken()
    def _acl_object_group_icmp_id_(self):
        with self._ifnot():
            pass

    @graken()
    def _acl_object_group_protocol_id_(self):
        with self._ifnot():
            pass

    @graken()
    def _acl_names_id_(self):
        with self._ifnot():
            pass

    @graken()
    def _acl_time_range_id_(self):
        with self._ifnot():
            pass

    @graken()
    def _acl_host_(self):
        with self._choice():
            with self._option():
                with self._group():
                    with self._choice():
                        with self._option():
                            self._token('host')
                        with self._option():
                            self._token('ip')
                        self._error('expecting one of: host ip')
                self.ast['type'] = self.last_node
                with self._group():
                    with self._choice():
                        with self._option():
                            self._acl_names_id_()
                        with self._option():
                            self._ip4_()
                        with self._option():
                            self._ip6_()
                        self._error('no available options')
                self.ast['address'] = self.last_node
            with self._option():
                self._token('interface')
                self.ast['type'] = self.last_node
                self._identifier_()
                self.ast['name'] = self.last_node
            with self._option():
                with self._group():
                    with self._choice():
                        with self._option():
                            self._token('any')
                        with self._option():
                            self._token('any4')
                        with self._option():
                            self._token('any6')
                        self._error('expecting one of: any any4 any6')
                self.ast['type'] = self.last_node
            with self._option():
                self._token('object')
                self.ast['type'] = self.last_node
                self._acl_object_network_id_()
                self.ast['name'] = self.last_node
            with self._option():
                self._token('object-group')
                self.ast['type'] = self.last_node
                self._acl_object_group_network_id_()
                self.ast['name'] = self.last_node
            with self._option():
                with self._group():
                    with self._choice():
                        with self._option():
                            self._acl_names_id_()
                        with self._option():
                            self._ip4_()
                        self._error('no available options')
                self.ast['address'] = self.last_node
                self._ip4_()
                self.ast['netmask'] = self.last_node
            with self._option():
                with self._group():
                    with self._choice():
                        with self._option():
                            self._acl_names_id_()
                        with self._option():
                            self._ip6_()
                        self._error('no available options')
                self.ast['address'] = self.last_node
                self._token('/')
                self._int_()
                self.ast['netmask'] = self.last_node
            self._error('expecting one of: any any4 any6')

        self.ast._define(
            ['type', 'address', 'name', 'netmask'],
            []
        )

    @graken()
    def _acl_port_(self):
        with self._choice():
            with self._option():
                self._token('object-group')
                self.ast['type'] = self.last_node
                self._acl_object_group_service_id_()
                self.ast['name'] = self.last_node
            with self._option():
                with self._group():
                    with self._choice():
                        with self._option():
                            self._token('gt')
                        with self._option():
                            self._token('lt')
                        with self._option():
                            self._token('eq')
                        self._error('expecting one of: eq gt lt')
                self.ast['op'] = self.last_node
                self._port_()
                self.ast['port'] = self.last_node
            with self._option():
                self._token('range')
                self.ast['type'] = self.last_node
                self._port_()
                self.ast['start'] = self.last_node
                self._port_()
                self.ast['stop'] = self.last_node
            self._error('no available options')

        self.ast._define(
            ['type', 'name', 'op', 'port', 'start', 'stop'],
            []
        )

    @graken()
    def _acl_icmp_options_(self):
        with self._choice():
            with self._option():
                self._token('object-group')
                self.ast['type'] = self.last_node
                self._acl_object_group_icmp_id_()
                self.ast['object'] = self.last_node
            with self._option():
                with self._group():
                    with self._choice():
                        with self._option():
                            self._icmp_type_()
                        with self._option():
                            self._int_()
                        self._error('no available options')
                self.ast['type'] = self.last_node
                with self._optional():
                    self._int_()
                self.ast['code'] = self.last_node
            with self._option():
                pass
            self._error('no available options')

        self.ast._define(
            ['type', 'object', 'code'],
            []
        )

    @graken()
    def _acl_options_(self):

        def block0():
            self._acl_option_()
        self._closure(block0)

    @graken()
    def _acl_option_(self):
        with self._choice():
            with self._option():
                self._token('log')
                self.ast['type'] = self.last_node

                def block2():
                    self._acl_option_log_option_()
                self._closure(block2)
                self.ast['options'] = self.last_node
            with self._option():
                self._token('time-range')
                self.ast['type'] = self.last_node
                self._acl_time_range_id_()
                self.ast['option'] = self.last_node
            with self._option():
                self._token('inactive')
                self.ast['type'] = self.last_node
            with self._option():
                pass
            self._error('expecting one of: inactive log')

        self.ast._define(
            ['type', 'options', 'option'],
            []
        )

    @graken()
    def _acl_option_log_option_(self):
        with self._choice():
            with self._option():
                with self._group():
                    with self._choice():
                        with self._option():
                            self._token('disable')
                        with self._option():
                            self._token('default')
                        with self._option():
                            self._token('notifications')
                        with self._option():
                            self._token('warnings')
                        self._error('expecting one of: default disable notifications warnings')
            with self._option():
                self._token('interval')
                self._int_()
            with self._option():
                pass
            self._error('expecting one of: default disable notifications warnings')

    @graken()
    def _acl_icmp_node_(self):
        self._acl_host_()

    @graken()
    def _remark_(self):
        with self._group():
            self._pattern(r'[^\n]*')

    @graken()
    def _object_(self):
        self._token('object')
        self._object_type_()

    @graken()
    def _object_type_(self):
        with self._choice():
            with self._option():
                self._token('network')
                self.ast['type'] = self.last_node
                self._obj_name_()
                self.ast['name'] = self.last_node
                self._NL_()
                self._network_object_()
                self.ast['args'] = self.last_node
                with self._choice():
                    with self._option():
                        self._token('description')
                        self._pattern(r'[^\n]+')
                        self.ast['description'] = self.last_node
                        self._NL_()
                    with self._option():
                        pass
                    self._error('no available options')
            with self._option():
                self._token('service')
                self.ast['type'] = self.last_node
                self._obj_name_()
                self.ast['name'] = self.last_node
                self._NL_()
                self._service_object_()
                self.ast['args'] = self.last_node
                with self._choice():
                    with self._option():
                        self._token('description')
                        self._pattern(r'[^\n]+')
                        self.ast['description'] = self.last_node
                        self._NL_()
                    with self._option():
                        pass
                    self._error('no available options')
            self._error('no available options')

        self.ast._define(
            ['type', 'name', 'args', 'description'],
            []
        )

    @graken()
    def _network_object_(self):
        with self._choice():
            with self._option():
                self._token('host')
                self.ast['type'] = self.last_node
                with self._group():
                    with self._choice():
                        with self._option():
                            self._ip4_()
                        with self._option():
                            self._ip6_()
                        self._error('no available options')
                self.ast['address'] = self.last_node
                self._NL_()
            with self._option():
                self._token('subnet')
                self.ast['type'] = self.last_node
                self._ip4_()
                self.ast['address'] = self.last_node
                self._ip4_()
                self.ast['mask'] = self.last_node
                self._NL_()
            with self._option():
                self._token('subnet')
                self.ast['type'] = self.last_node
                self._ip6_()
                self.ast['address'] = self.last_node
                self._token('/')
                self._int_()
                self.ast['mask'] = self.last_node
                self._NL_()
            with self._option():
                self._token('range')
                self.ast['type'] = self.last_node
                self._ip4_()
                self.ast['start'] = self.last_node
                self._ip4_()
                self.ast['stop'] = self.last_node
                self._NL_()
            with self._option():
                self._token('range')
                self.ast['type'] = self.last_node
                self._ip6_()
                self.ast['start'] = self.last_node
                self._ip6_()
                self.ast['stop'] = self.last_node
                self._NL_()
            with self._option():
                self._token('fqdn')
                self.ast['type'] = self.last_node
                with self._optional():
                    with self._group():
                        with self._choice():
                            with self._option():
                                self._token('v4')
                            with self._option():
                                self._token('v6')
                            self._error('expecting one of: v4 v6')
                self.ast['limit'] = self.last_node
                self._string_()
                self.ast['fqdn'] = self.last_node
                self._NL_()
            self._error('no available options')

        self.ast._define(
            ['type', 'address', 'mask', 'start', 'stop', 'limit', 'fqdn'],
            []
        )

    @graken()
    def _service_object_(self):
        with self._choice():
            with self._option():
                self._token('service')
                self.ast['type'] = self.last_node
                self._int_()
                self.ast['protocol'] = self.last_node
                self._NL_()
            with self._option():
                self._token('service')
                self.ast['type'] = self.last_node
                self._protocol_icmp_()
                self.ast['protocol'] = self.last_node
                with self._optional():
                    with self._group():
                        with self._choice():
                            with self._option():
                                self._icmp_type_()
                            with self._option():
                                self._int_()
                            self._error('no available options')
                self.ast['icmp_type'] = self.last_node
                with self._optional():
                    self._int_()
                self.ast['icmp_code'] = self.last_node
                self._NL_()
            with self._option():
                self._token('service')
                self.ast['type'] = self.last_node
                self._protocol_()
                self.ast['protocol'] = self.last_node
                self._service_object_source_()
                self.ast['source'] = self.last_node
                self._service_object_destination_()
                self.ast['destination'] = self.last_node
                self._NL_()
            self._error('no available options')

        self.ast._define(
            ['type', 'protocol', 'icmp_type', 'icmp_code', 'source', 'destination'],
            []
        )

    @graken()
    def _service_object_op_(self):
        with self._choice():
            with self._option():
                with self._group():
                    with self._choice():
                        with self._option():
                            self._token('lt')
                        with self._option():
                            self._token('gt')
                        with self._option():
                            self._token('eq')
                        with self._option():
                            self._token('neq')
                        self._error('expecting one of: eq gt lt neq')
                self._port_()
            with self._option():
                self._token('range')
                self._port_()
                self._port_()
            self._error('no available options')

    @graken()
    def _service_object_source_(self):
        with self._choice():
            with self._option():
                self._token('source')
                self._service_object_op_()
                self.ast['@'] = self.last_node
            with self._option():
                pass
            self._error('no available options')

    @graken()
    def _service_object_destination_(self):
        with self._choice():
            with self._option():
                self._token('destination')
                self._service_object_op_()
                self.ast['@'] = self.last_node
            with self._option():
                pass
            self._error('no available options')

    @graken()
    def _object_group_(self):
        self._token('object-group')
        self._object_group_type_()

    @graken()
    def _protocol_icmp_(self):
        with self._choice():
            with self._option():
                self._token('icmp')
            with self._option():
                self._token('icmp6')
            self._error('expecting one of: icmp icmp6')

    @graken()
    def _protocol_(self):
        self._port_group_protocol_()

    @graken()
    def _port_group_protocol_(self):
        with self._group():
            with self._choice():
                with self._option():
                    self._token('tcp-udp')
                with self._option():
                    self._token('tcp')
                with self._option():
                    self._token('udp')
                self._error('expecting one of: tcp tcp-udp udp')

    @graken()
    def _object_group_type_(self):
        with self._choice():
            with self._option():
                self._token('network')
                self.ast['type'] = self.last_node
                self._obj_name_()
                self.ast['name'] = self.last_node
                self._NL_()
                with self._choice():
                    with self._option():
                        self._token('description')
                        self._pattern(r'[^\n]+')
                        self.ast['description'] = self.last_node
                        self._NL_()
                    with self._option():
                        pass
                    self._error('no available options')


                def block5():
                    self._network_group_object_()
                self._closure(block5)
                self.ast['objects'] = self.last_node
            with self._option():
                self._token('service')
                self._obj_name_()
                self.ast['name'] = self.last_node
                self._port_group_protocol_()
                self.ast['type'] = self.last_node
                self._NL_()
                with self._choice():
                    with self._option():
                        self._token('description')
                        self._pattern(r'[^\n]+')
                        self.ast['description'] = self.last_node
                        self._NL_()
                    with self._option():
                        pass
                    self._error('no available options')


                def block11():
                    self._port_group_object_()
                self._closure(block11)
                self.ast['objects'] = self.last_node
            with self._option():
                self._token('service')
                self.ast['type'] = self.last_node
                self._obj_name_()
                self.ast['name'] = self.last_node
                self._NL_()
                with self._choice():
                    with self._option():
                        self._token('description')
                        self._pattern(r'[^\n]+')
                        self.ast['description'] = self.last_node
                        self._NL_()
                    with self._option():
                        pass
                    self._error('no available options')


                def block17():
                    self._service_group_object_()
                self._closure(block17)
                self.ast['objects'] = self.last_node
            with self._option():
                self._token('icmp-type')
                self.ast['type'] = self.last_node
                self._obj_name_()
                self.ast['name'] = self.last_node
                self._NL_()
                with self._choice():
                    with self._option():
                        self._token('description')
                        self._pattern(r'[^\n]+')
                        self.ast['description'] = self.last_node
                        self._NL_()
                    with self._option():
                        pass
                    self._error('no available options')


                def block23():
                    self._icmp_group_object_()
                self._closure(block23)
                self.ast['objects'] = self.last_node
            with self._option():
                self._token('protocol')
                self.ast['type'] = self.last_node
                self._obj_name_()
                self.ast['name'] = self.last_node
                self._NL_()
                with self._choice():
                    with self._option():
                        self._token('description')
                        self._pattern(r'[^\n]+')
                        self.ast['description'] = self.last_node
                        self._NL_()
                    with self._option():
                        pass
                    self._error('no available options')


                def block29():
                    self._protocol_group_object_()
                self._closure(block29)
                self.ast['objects'] = self.last_node
            self._error('no available options')

        self.ast._define(
            ['type', 'name', 'description', 'objects'],
            []
        )

    @graken()
    def _service_group_object_(self):
        with self._choice():
            with self._option():
                self._token('service-object')
                self.ast['type'] = self.last_node
                self._int_()
                self.ast['protocol'] = self.last_node
                self._NL_()
            with self._option():
                self._token('service-object')
                self.ast['type'] = self.last_node
                self._protocol_icmp_()
                self.ast['protocol'] = self.last_node
                with self._optional():
                    with self._group():
                        with self._choice():
                            with self._option():
                                self._icmp_type_()
                            with self._option():
                                self._int_()
                            self._error('no available options')
                self.ast['icmp_type'] = self.last_node
                with self._optional():
                    self._int_()
                self.ast['icmp_code'] = self.last_node
                self._NL_()
            with self._option():
                self._token('service-object')
                self.ast['type'] = self.last_node
                self._protocol_()
                self.ast['protocol'] = self.last_node
                self._service_object_source_()
                self.ast['source'] = self.last_node
                self._service_object_destination_()
                self.ast['destination'] = self.last_node
                self._NL_()
            with self._option():
                self._token('service-object')
                self.ast['type'] = self.last_node
                self._token('object')
                self.ast['protocol'] = self.last_node
                self._acl_object_service_id_()
                self.ast['object'] = self.last_node
                self._NL_()
            with self._option():
                self._token('group-object')
                self.ast['type'] = self.last_node
                self._acl_object_group_service_id_()
                self.ast['object'] = self.last_node
                self._NL_()
            with self._option():
                pass
            self._error('no available options')

        self.ast._define(
            ['type', 'protocol', 'icmp_type', 'icmp_code', 'source', 'destination', 'object'],
            []
        )

    @graken()
    def _port_group_object_(self):
        with self._choice():
            with self._option():
                self._token('port-object')
                self._token('eq')
                self._port_()
                self._NL_()
            with self._option():
                self._token('port-object')
                self._token('range')
                self._port_()
                self._port_()
                self._NL_()
            with self._option():
                self._token('group-object')
                self._acl_object_group_service_id_()
                self._NL_()
            with self._option():
                pass
            self._error('no available options')

    @graken()
    def _network_group_object_(self):
        with self._choice():
            with self._option():
                self._token('network-object')
                self.ast['type'] = self.last_node
                self._token('host')
                self.ast['name'] = self.last_node
                with self._group():
                    with self._choice():
                        with self._option():
                            self._acl_names_id_()
                        with self._option():
                            self._ip4_()
                        with self._option():
                            self._ip6_()
                        self._error('no available options')
                self.ast['address'] = self.last_node
                self._NL_()
            with self._option():
                self._token('network-object')
                self.ast['type'] = self.last_node
                self._token('object')
                self.ast['name'] = self.last_node
                self._acl_object_network_id_()
                self.ast['object'] = self.last_node
                self._NL_()
            with self._option():
                self._token('network-object')
                self.ast['type'] = self.last_node
                with self._group():
                    with self._choice():
                        with self._option():
                            self._acl_names_id_()
                        with self._option():
                            self._ip4_()
                        self._error('no available options')
                self.ast['name'] = self.last_node
                self._ip4_()
                self.ast['netmask'] = self.last_node
                self._NL_()
            with self._option():
                self._token('network-object')
                self.ast['type'] = self.last_node
                with self._group():
                    with self._choice():
                        with self._option():
                            self._acl_names_id_()
                        with self._option():
                            self._ip6_()
                        self._error('no available options')
                self.ast['name'] = self.last_node
                self._token('/')
                self._int_()
                self.ast['netmask'] = self.last_node
                self._NL_()
            with self._option():
                self._token('group-object')
                self.ast['type'] = self.last_node
                self._acl_object_group_network_id_()
                self.ast['object'] = self.last_node
                self._NL_()
            with self._option():
                pass
            self._error('no available options')

        self.ast._define(
            ['type', 'name', 'address', 'object', 'netmask'],
            []
        )

    @graken()
    def _icmp_group_object_(self):
        with self._choice():
            with self._option():
                self._token('icmp-object')
                self.ast['type'] = self.last_node
                with self._group():
                    with self._choice():
                        with self._option():
                            self._icmp_type_()
                        with self._option():
                            self._int_()
                        self._error('no available options')
                self.ast['name'] = self.last_node
                self._NL_()
            with self._option():
                self._token('group-object')
                self.ast['type'] = self.last_node
                self._acl_object_group_icmp_id_()
                self.ast['name'] = self.last_node
                self._NL_()
            with self._option():
                pass
            self._error('no available options')

        self.ast._define(
            ['type', 'name'],
            []
        )

    @graken()
    def _protocol_group_object_(self):
        with self._choice():
            with self._option():
                self._token('protocol-object')
                self.ast['type'] = self.last_node
                self._obj_name_()
                self.ast['name'] = self.last_node
                self._NL_()
            with self._option():
                self._token('group-object')
                self.ast['type'] = self.last_node
                self._acl_object_group_protocol_id_()
                self.ast['name'] = self.last_node
                self._NL_()
            with self._option():
                pass
            self._error('no available options')

        self.ast._define(
            ['type', 'name'],
            []
        )

    @graken()
    def _port_(self):
        with self._group():
            with self._choice():
                with self._option():
                    self._port_code_()
                with self._option():
                    self._int_()
                self._error('no available options')

    @graken()
    def _hour_(self):
        self._pattern(r'[0-9]{1,2}')

    @graken()
    def _minute_(self):
        self._pattern(r'[0-9]{1,2}')

    @graken()
    def _time_(self):
        self._hour_()
        self.ast['hour'] = self.last_node
        self._token(':')
        self._minute_()
        self.ast['minute'] = self.last_node

        self.ast._define(
            ['hour', 'minute'],
            []
        )

    @graken()
    def _year_(self):
        self._pattern(r'[0-9]{4}')

    @graken()
    def _day_(self):
        self._pattern(r'[0-9]{1,2}')

    @graken()
    def _date_(self):
        self._day_()
        self.ast['day'] = self.last_node
        self._month_()
        self.ast['month'] = self.last_node
        self._year_()
        self.ast['year'] = self.last_node

        self.ast._define(
            ['day', 'month', 'year'],
            []
        )

    @graken()
    def _timedate_(self):
        self._hour_()
        self.ast['hour'] = self.last_node
        self._token(':')
        self._minute_()
        self.ast['minute'] = self.last_node

        self._day_()
        self.ast['day'] = self.last_node
        self._month_()
        self.ast['month'] = self.last_node
        self._year_()
        self.ast['year'] = self.last_node

        self.ast._define(
            ['hour', 'minute', 'day', 'month', 'year'],
            []
        )

    @graken()
    def _time_range_object_(self):
        with self._choice():
            with self._option():
                self._token('periodic')
                self.ast['type'] = self.last_node

                def block2():
                    self._day_of_the_week_()
                self._positive_closure(block2)

                self.ast['days'] = self.last_node
                self._time_()
                self.ast['start'] = self.last_node
                self._token('to')
                with self._optional():
                    self._day_of_the_week_()
                self.ast['edays'] = self.last_node
                self._time_()
                self.ast['end'] = self.last_node
                self._NL_()
            with self._option():
                self._token('periodic')
                self.ast['type'] = self.last_node
                with self._group():
                    with self._choice():
                        with self._option():
                            self._token('weekdays')
                        with self._option():
                            self._token('weekend')
                        with self._option():
                            self._token('daily')
                        self._error('expecting one of: daily weekdays weekend')
                self.ast.setlist('days', self.last_node)
                self._time_()
                self.ast['start'] = self.last_node
                self._token('to')
                self._time_()
                self.ast['end'] = self.last_node
                self._NL_()
            with self._option():
                self._token('absolute')
                self.ast['type'] = self.last_node
                with self._optional():
                    self._token('start')
                    self._timedate_()
                    self.ast['start'] = self.last_node
                with self._optional():
                    self._token('end')
                    self._timedate_()
                    self.ast['end'] = self.last_node
                self._NL_()
            with self._option():
                self._token('no')
                self.ast['type'] = self.last_node
                with self._group():
                    with self._choice():
                        with self._option():
                            self._token('periodic')
                        with self._option():
                            self._token('absolute')
                        self._error('expecting one of: absolute periodic')
                self.ast['any'] = self.last_node
                self._NL_()
            self._error('no available options')

        self.ast._define(
            ['type', 'days', 'start', 'edays', 'end', 'any'],
            ['days']
        )

    @graken()
    def _time_range_(self):
        self._token('time-range')
        self._string_()
        self.ast['name'] = self.last_node
        self._NL_()

        def block2():
            self._time_range_object_()
        self._positive_closure(block2)

        self.ast['objects'] = self.last_node
        self._token('!')
        self._NL_()

        self.ast._define(
            ['name', 'objects'],
            []
        )

    @graken()
    def _day_of_the_week_(self):
        with self._choice():
            with self._option():
                self._token('Monday')
            with self._option():
                self._token('Tuesday')
            with self._option():
                self._token('Wednesday')
            with self._option():
                self._token('Thursday')
            with self._option():
                self._token('Friday')
            with self._option():
                self._token('Saturday')
            with self._option():
                self._token('Sunday')
            self._error('expecting one of: Friday Monday Saturday Sunday Thursday Tuesday Wednesday')

    @graken()
    def _month_(self):
        with self._choice():
            with self._option():
                self._token('January')
            with self._option():
                self._token('February')
            with self._option():
                self._token('March')
            with self._option():
                self._token('April')
            with self._option():
                self._token('May')
            with self._option():
                self._token('June')
            with self._option():
                self._token('July')
            with self._option():
                self._token('August')
            with self._option():
                self._token('September')
            with self._option():
                self._token('October')
            with self._option():
                self._token('November')
            with self._option():
                self._token('December')
            self._error('expecting one of: April August December February January July June March May November October September')

    @graken()
    def _icmp_type_(self):
        with self._choice():
            with self._option():
                self._token('unreachable')
            with self._option():
                self._token('traceroute')
            with self._option():
                self._token('timestamp-request')
            with self._option():
                self._token('timestamp-reply')
            with self._option():
                self._token('time-exceeded')
            with self._option():
                self._token('source-quench')
            with self._option():
                self._token('router-solicitation')
            with self._option():
                self._token('router-advertisement')
            with self._option():
                self._token('redirect')
            with self._option():
                self._token('parameter-problem')
            with self._option():
                self._token('mobile-redirect')
            with self._option():
                self._token('mask-request')
            with self._option():
                self._token('mask-reply')
            with self._option():
                self._token('information-request')
            with self._option():
                self._token('information-reply')
            with self._option():
                self._token('echo-reply')
            with self._option():
                self._token('echo')
            with self._option():
                self._token('ttl-exceeded')
            self._error('expecting one of: echo echo-reply information-reply information-request mask-reply mask-request mobile-redirect parameter-problem redirect router-advertisement router-solicitation source-quench time-exceeded timestamp-reply timestamp-request traceroute ttl-exceeded unreachable')

    @graken()
    def _protocol_code_(self):
        with self._choice():
            with self._option():
                self._token('ip')
            with self._option():
                self._token('icmp')
            with self._option():
                self._token('igmp')
            with self._option():
                self._token('ipinip')
            with self._option():
                self._token('tcp')
            with self._option():
                self._token('igrp')
            with self._option():
                self._token('udp')
            with self._option():
                self._token('gre')
            with self._option():
                self._token('pptp')
            with self._option():
                self._token('esp')
            with self._option():
                self._token('ipsec')
            with self._option():
                self._token('ahp')
            with self._option():
                self._token('ah')
            with self._option():
                self._token('icmp6')
            with self._option():
                self._token('eigrp')
            with self._option():
                self._token('ospf')
            with self._option():
                self._token('nos')
            with self._option():
                self._token('pim')
            with self._option():
                self._token('pcp')
            with self._option():
                self._token('snp')
            self._error('expecting one of: ah ahp eigrp esp gre icmp icmp6 igmp igrp ip ipinip ipsec nos ospf pcp pim pptp snp tcp udp')

    @graken()
    def _port_code_(self):
        with self._choice():
            with self._option():
                self._token('aol')
            with self._option():
                self._token('bgp')
            with self._option():
                self._token('biff')
            with self._option():
                self._token('bootpc')
            with self._option():
                self._token('bootps')
            with self._option():
                self._token('chargen')
            with self._option():
                self._token('citrix-ica')
            with self._option():
                self._token('cmd')
            with self._option():
                self._token('ctiqbe')
            with self._option():
                self._token('daytime')
            with self._option():
                self._token('discard')
            with self._option():
                self._token('domain')
            with self._option():
                self._token('dnsix')
            with self._option():
                self._token('echo')
            with self._option():
                self._token('exec')
            with self._option():
                self._token('finger')
            with self._option():
                self._token('ftp-data')
            with self._option():
                self._token('ftp')
            with self._option():
                self._token('gopher')
            with self._option():
                self._token('https')
            with self._option():
                self._token('h323')
            with self._option():
                self._token('hostname')
            with self._option():
                self._token('ident')
            with self._option():
                self._token('imap4')
            with self._option():
                self._token('irc')
            with self._option():
                self._token('isakmp')
            with self._option():
                self._token('kerberos')
            with self._option():
                self._token('klogin')
            with self._option():
                self._token('kshell')
            with self._option():
                self._token('ldap')
            with self._option():
                self._token('ldaps')
            with self._option():
                self._token('lpd')
            with self._option():
                self._token('login')
            with self._option():
                self._token('lotusnotes')
            with self._option():
                self._token('mobile-ip')
            with self._option():
                self._token('nameserver')
            with self._option():
                self._token('netbios-ns')
            with self._option():
                self._token('netbios-dgm')
            with self._option():
                self._token('netbios-ssn')
            with self._option():
                self._token('netbios-ss')
            with self._option():
                self._token('nntp')
            with self._option():
                self._token('non500-isakmp')
            with self._option():
                self._token('ntp')
            with self._option():
                self._token('pcanywhere-status')
            with self._option():
                self._token('pcanywhere-data')
            with self._option():
                self._token('pim-auto-rp')
            with self._option():
                self._token('pop2')
            with self._option():
                self._token('pop3')
            with self._option():
                self._token('pptp')
            with self._option():
                self._token('radius')
            with self._option():
                self._token('radius-acct')
            with self._option():
                self._token('rip')
            with self._option():
                self._token('rpc')
            with self._option():
                self._token('rtsp')
            with self._option():
                self._token('rsh')
            with self._option():
                self._token('secureid-udp')
            with self._option():
                self._token('sip')
            with self._option():
                self._token('smtp')
            with self._option():
                self._token('snmp')
            with self._option():
                self._token('snmptrap')
            with self._option():
                self._token('sqlnet')
            with self._option():
                self._token('ssh')
            with self._option():
                self._token('sunrpc')
            with self._option():
                self._token('syslog')
            with self._option():
                self._token('tacacs')
            with self._option():
                self._token('talk')
            with self._option():
                self._token('telnet')
            with self._option():
                self._token('tftp')
            with self._option():
                self._token('time')
            with self._option():
                self._token('uucp')
            with self._option():
                self._token('who')
            with self._option():
                self._token('whois')
            with self._option():
                self._token('www')
            with self._option():
                self._token('xdmcp')
            self._error('expecting one of: aol bgp biff bootpc bootps chargen citrix-ica cmd ctiqbe daytime discard dnsix domain echo exec finger ftp ftp-data gopher h323 hostname https ident imap4 irc isakmp kerberos klogin kshell ldap ldaps login lotusnotes lpd mobile-ip nameserver netbios-dgm netbios-ns netbios-ss netbios-ssn nntp non500-isakmp ntp pcanywhere-data pcanywhere-status pim-auto-rp pop2 pop3 pptp radius radius-acct rip rpc rsh rtsp secureid-udp sip smtp snmp snmptrap sqlnet ssh sunrpc syslog tacacs talk telnet tftp time uucp who whois www xdmcp')

    @graken()
    def _grammar_(self):

        def block1():
            self._command_()
        self._positive_closure(block1)

        self.ast['@'] = self.last_node
        with self._group():
            with self._choice():
                with self._option():
                    self._token('line')
                with self._option():
                    self._token('end')
                with self._option():
                    self._check_eof()
                self._error('expecting one of: end line')

    @graken()
    def _version_(self):
        with self._group():
            self._token('version')
            self._pattern(r'[^\n]*')
        self.ast['version'] = self.last_node
        self._NL_()

        self.ast._define(
            ['version'],
            []
        )

    @graken()
    def _command_(self):
        with self._choice():
            with self._option():
                self._version_()
            with self._option():
                self._hostname_()
            with self._option():
                self._domain_name_()
            with self._option():
                self._interface_()
            with self._option():
                self._access_list_()
            with self._option():
                self._ip_()
            with self._option():
                self._ignored_()
            self._error('no available options')

    @graken()
    def _ip_(self):
        self._token('ip')
        self._ip_command_()
        self.ast['cmd'] = self.last_node

        self.ast._define(
            ['cmd'],
            []
        )

    @graken()
    def _ip_command_(self):
        with self._choice():
            with self._option():
                self._token('access-list')
                self.ast['cmd'] = self.last_node
                self._ip_access_list_()
                self.ast['object'] = self.last_node
            with self._option():
                self._token('domain name')
                self.ast['cmd'] = self.last_node
                self._obj_name_()
                self.ast['name'] = self.last_node
            with self._option():
                self._ip_ignored_()
            self._error('no available options')

        self.ast._define(
            ['cmd', 'object', 'name'],
            []
        )

    @graken()
    def _ip_access_list_(self):
        with self._choice():
            with self._option():
                self._token('standard')
                self.ast['type'] = self.last_node
                self._obj_name_()
                self.ast['name'] = self.last_node
                self._NL_()

                def block3():
                    self._ip_access_list_standard_()
                self._positive_closure(block3)

                self.ast['objects'] = self.last_node
            with self._option():
                self._token('extended')
                self.ast['type'] = self.last_node
                self._obj_name_()
                self.ast['name'] = self.last_node
                self._NL_()

                def block7():
                    self._ip_access_list_extended_()
                self._positive_closure(block7)

                self.ast['objects'] = self.last_node
            self._error('no available options')

        self.ast._define(
            ['type', 'name', 'objects'],
            []
        )

    @graken()
    def _ip_access_list_standard_rule_option_(self):
        self._token('log')
        self.ast['type'] = self.last_node
        with self._optional():
            self._identifier_()
        self.ast['value'] = self.last_node

        self.ast._define(
            ['type', 'value'],
            []
        )

    @graken()
    def _ip_access_list_standard_rule_options_(self):

        def block0():
            self._ip_access_list_standard_rule_option_()
        self._closure(block0)

    @graken()
    def _ip_access_list_remark_(self):
        with self._optional():
            self._int_()
        self.ast['seq'] = self.last_node
        self._token('remark')
        self._remark_()
        self.ast['remark'] = self.last_node
        self._NL_()

        self.ast._define(
            ['seq', 'remark'],
            []
        )

    @graken()
    def _ip_access_list_standard_rule_(self):
        with self._optional():
            self._int_()
        self.ast['seq'] = self.last_node
        self._acl_mode_()
        self.ast['mode'] = self.last_node
        self._ios_host_()
        self.ast['source'] = self.last_node
        self._ip_access_list_standard_rule_options_()
        self.ast['options'] = self.last_node
        self._NL_()

        self.ast._define(
            ['seq', 'mode', 'source', 'options'],
            []
        )

    @graken()
    def _ios_host_(self):
        with self._choice():
            with self._option():
                self._ip4_()
                self.ast['address'] = self.last_node
                with self._optional():
                    self._ip4_()
                self.ast['wildcard'] = self.last_node
            with self._option():
                self._token('host')
                self._ip4_()
                self.ast['address'] = self.last_node
            with self._option():
                self._token('any')
                self.ast['address'] = self.last_node
            self._error('expecting one of: any')

        self.ast._define(
            ['address', 'wildcard'],
            []
        )

    @graken()
    def _ios_node_(self):
        self._ios_host_()
        self.ast['host'] = self.last_node
        with self._optional():
            self._acl_port_()
            self.ast['port'] = self.last_node

        self.ast._define(
            ['host', 'port'],
            []
        )

    @graken()
    def _ip_access_list_standard_(self):
        with self._choice():
            with self._option():
                with self._optional():
                    self._int_()
                self.ast['seq'] = self.last_node

                def block2():
                    self._ip_access_list_remark_()
                self._positive_closure(block2)

                self.ast['remark'] = self.last_node
                self._cut()
                with self._optional():
                    self._int_()
                self.ast['seq'] = self.last_node
                self._acl_mode_()
                self.ast['mode'] = self.last_node
                self._ios_host_()
                self.ast['source'] = self.last_node
                self._ip_access_list_standard_rule_options_()
                self.ast['options'] = self.last_node
                self._NL_()
            with self._option():
                with self._optional():
                    self._int_()
                self.ast['seq'] = self.last_node
                self._acl_mode_()
                self.ast['mode'] = self.last_node
                self._ios_host_()
                self.ast['source'] = self.last_node
                self._ip_access_list_standard_rule_options_()
                self.ast['options'] = self.last_node
                self._NL_()
            self._error('no available options')

        self.ast._define(
            ['seq', 'remark', 'mode', 'source', 'options'],
            []
        )

    @graken()
    def _ip_access_list_extended_rule_option_(self):
        with self._choice():
            with self._option():
                self._token('precedence')
                self.ast['type'] = self.last_node
                self._identifier_()
                self.ast['value'] = self.last_node
            with self._option():
                self._token('dscp')
                self.ast['type'] = self.last_node
                self._identifier_()
                self.ast['value'] = self.last_node
            with self._option():
                self._token('tos')
                self.ast['type'] = self.last_node
                self._identifier_()
                self.ast['value'] = self.last_node
            with self._option():
                self._token('time-range')
                self.ast['type'] = self.last_node
                self._identifier_()
                self.ast['value'] = self.last_node
            with self._option():
                self._token('fragments')
                self.ast['type'] = self.last_node
            with self._option():
                self._token('log-input')
                self.ast['type'] = self.last_node
                with self._optional():
                    self._identifier_()
                self.ast['value'] = self.last_node
            with self._option():
                self._token('log')
                self.ast['type'] = self.last_node
                with self._optional():
                    self._identifier_()
                self.ast['value'] = self.last_node
            with self._option():
                self._token('established')
                self.ast['type'] = self.last_node
            self._error('expecting one of: established fragments log log-input')

        self.ast._define(
            ['type', 'value'],
            []
        )

    @graken()
    def _ip_access_list_extended_rule_options_(self):

        def block0():
            self._ip_access_list_extended_rule_option_()
        self._closure(block0)

    @graken()
    def _ip_access_list_extended_rule_(self):
        with self._choice():
            with self._option():
                with self._optional():
                    self._int_()
                self.ast['seq'] = self.last_node
                self._acl_mode_()
                self.ast['mode'] = self.last_node
                self._protocol_icmp_()
                self.ast['protocol'] = self.last_node
                self._ios_host_()
                self.ast['source'] = self.last_node
                self._ios_host_()
                self.ast['dest'] = self.last_node
                self._acl_icmp_options_()
                self.ast['icmp'] = self.last_node
                self._ip_access_list_extended_rule_options_()
                self.ast['options'] = self.last_node
                self._NL_()
            with self._option():
                with self._optional():
                    self._int_()
                self.ast['seq'] = self.last_node
                self._acl_mode_()
                self.ast['mode'] = self.last_node
                self._acl_protocol_()
                self.ast['protocol'] = self.last_node
                self._ios_node_()
                self.ast['source'] = self.last_node
                self._ios_node_()
                self.ast['dest'] = self.last_node
                self._ip_access_list_extended_rule_options_()
                self.ast['options'] = self.last_node
                self._NL_()
            with self._option():
                with self._optional():
                    self._int_()
                self.ast['seq'] = self.last_node
                self._acl_mode_()
                self.ast['mode'] = self.last_node
                self._acl_protocol_()
                self.ast['protocol'] = self.last_node
                self._ios_host_()
                self.ast['source'] = self.last_node
                self._ios_host_()
                self.ast['dest'] = self.last_node
                self._ip_access_list_extended_rule_options_()
                self.ast['options'] = self.last_node
                self._NL_()
            self._error('no available options')

        self.ast._define(
            ['seq', 'mode', 'protocol', 'source', 'dest', 'icmp', 'options'],
            []
        )

    @graken()
    def _ip_access_list_extended_(self):
        with self._choice():
            with self._option():
                with self._optional():
                    self._int_()
                self.ast['seq'] = self.last_node

                def block2():
                    self._ip_access_list_remark_()
                self._positive_closure(block2)

                self.ast['remark'] = self.last_node
                self._cut()
                with self._choice():
                    with self._option():
                        with self._optional():
                            self._int_()
                        self.ast['seq'] = self.last_node
                        self._acl_mode_()
                        self.ast['mode'] = self.last_node
                        self._protocol_icmp_()
                        self.ast['protocol'] = self.last_node
                        self._ios_host_()
                        self.ast['source'] = self.last_node
                        self._ios_host_()
                        self.ast['dest'] = self.last_node
                        self._acl_icmp_options_()
                        self.ast['icmp'] = self.last_node
                        self._ip_access_list_extended_rule_options_()
                        self.ast['options'] = self.last_node
                        self._NL_()
                    with self._option():
                        with self._optional():
                            self._int_()
                        self.ast['seq'] = self.last_node
                        self._acl_mode_()
                        self.ast['mode'] = self.last_node
                        self._acl_protocol_()
                        self.ast['protocol'] = self.last_node
                        self._ios_node_()
                        self.ast['source'] = self.last_node
                        self._ios_node_()
                        self.ast['dest'] = self.last_node
                        self._ip_access_list_extended_rule_options_()
                        self.ast['options'] = self.last_node
                        self._NL_()
                    with self._option():
                        with self._optional():
                            self._int_()
                        self.ast['seq'] = self.last_node
                        self._acl_mode_()
                        self.ast['mode'] = self.last_node
                        self._acl_protocol_()
                        self.ast['protocol'] = self.last_node
                        self._ios_host_()
                        self.ast['source'] = self.last_node
                        self._ios_host_()
                        self.ast['dest'] = self.last_node
                        self._ip_access_list_extended_rule_options_()
                        self.ast['options'] = self.last_node
                        self._NL_()
                    self._error('no available options')
            with self._option():
                with self._choice():
                    with self._option():
                        with self._optional():
                            self._int_()
                        self.ast['seq'] = self.last_node
                        self._acl_mode_()
                        self.ast['mode'] = self.last_node
                        self._protocol_icmp_()
                        self.ast['protocol'] = self.last_node
                        self._ios_host_()
                        self.ast['source'] = self.last_node
                        self._ios_host_()
                        self.ast['dest'] = self.last_node
                        self._acl_icmp_options_()
                        self.ast['icmp'] = self.last_node
                        self._ip_access_list_extended_rule_options_()
                        self.ast['options'] = self.last_node
                        self._NL_()
                    with self._option():
                        with self._optional():
                            self._int_()
                        self.ast['seq'] = self.last_node
                        self._acl_mode_()
                        self.ast['mode'] = self.last_node
                        self._acl_protocol_()
                        self.ast['protocol'] = self.last_node
                        self._ios_node_()
                        self.ast['source'] = self.last_node
                        self._ios_node_()
                        self.ast['dest'] = self.last_node
                        self._ip_access_list_extended_rule_options_()
                        self.ast['options'] = self.last_node
                        self._NL_()
                    with self._option():
                        with self._optional():
                            self._int_()
                        self.ast['seq'] = self.last_node
                        self._acl_mode_()
                        self.ast['mode'] = self.last_node
                        self._acl_protocol_()
                        self.ast['protocol'] = self.last_node
                        self._ios_host_()
                        self.ast['source'] = self.last_node
                        self._ios_host_()
                        self.ast['dest'] = self.last_node
                        self._ip_access_list_extended_rule_options_()
                        self.ast['options'] = self.last_node
                        self._NL_()
                    self._error('no available options')
            self._error('no available options')

        self.ast._define(
            ['seq', 'remark', 'mode', 'protocol', 'source', 'dest', 'icmp', 'options'],
            []
        )

    @graken()
    def _host_wildcard_(self):
        self._ip4_()
        self.ast['host'] = self.last_node
        with self._optional():
            self._ip4_()
        self.ast['wildcard'] = self.last_node

        self.ast._define(
            ['host', 'wildcard'],
            []
        )

    @graken()
    def _access_list_ip_standard_rule_(self):
        self._token('access-list')
        self._access_list_ip_standard_id_()
        self.ast['id'] = self.last_node
        self._acl_mode_()
        self.ast['mode'] = self.last_node
        self._ios_host_()
        self.ast['source'] = self.last_node
        self._ip_access_list_standard_rule_options_()
        self.ast['options'] = self.last_node
        self._NL_()

        self.ast._define(
            ['id', 'mode', 'source', 'options'],
            []
        )

    @graken()
    def _access_list_ip_standard_(self):
        with self._choice():
            with self._option():

                def block1():
                    self._access_list_remark_()
                self._positive_closure(block1)

                self.ast['remark'] = self.last_node
                self._token('access-list')
                self._access_list_ip_standard_id_()
                self.ast['id'] = self.last_node
                self._acl_mode_()
                self.ast['mode'] = self.last_node
                self._ios_host_()
                self.ast['source'] = self.last_node
                self._ip_access_list_standard_rule_options_()
                self.ast['options'] = self.last_node
                self._NL_()
            with self._option():
                self._token('access-list')
                self._access_list_ip_standard_id_()
                self.ast['id'] = self.last_node
                self._acl_mode_()
                self.ast['mode'] = self.last_node
                self._ios_host_()
                self.ast['source'] = self.last_node
                self._ip_access_list_standard_rule_options_()
                self.ast['options'] = self.last_node
                self._NL_()
            self._error('no available options')

        self.ast._define(
            ['remark', 'id', 'mode', 'source', 'options'],
            []
        )

    @graken()
    def _access_list_remark_(self):
        self._token('access-list')
        self._acl_id_()
        self._token('remark')
        self._remark_()
        self.ast['remark'] = self.last_node
        self._NL_()

        self.ast._define(
            ['remark'],
            []
        )

    @graken()
    def _access_list_(self):
        with self._choice():
            with self._option():
                self._access_list_ip_extended_()
            with self._option():
                self._access_list_ip_standard_()
            self._error('no available options')

    @graken()
    def _access_list_ip_extended_rule_(self):
        with self._choice():
            with self._option():
                self._token('access-list')
                self._access_list_ip_extended_id_()
                self.ast['id'] = self.last_node
                self._acl_mode_()
                self.ast['mode'] = self.last_node
                self._protocol_icmp_()
                self.ast['protocol'] = self.last_node
                self._acl_icmp_node_()
                self.ast['source'] = self.last_node
                self._acl_icmp_node_()
                self.ast['dest'] = self.last_node
                self._acl_icmp_options_()
                self.ast['icmp'] = self.last_node
                self._ip_access_list_extended_rule_options_()
                self.ast['options'] = self.last_node
                self._NL_()
            with self._option():
                self._token('access-list')
                self._access_list_ip_extended_id_()
                self.ast['id'] = self.last_node
                self._acl_mode_()
                self.ast['mode'] = self.last_node
                self._acl_protocol_()
                self.ast['protocol'] = self.last_node
                self._node_()
                self.ast['source'] = self.last_node
                self._node_()
                self.ast['dest'] = self.last_node
                self._ip_access_list_extended_rule_options_()
                self.ast['options'] = self.last_node
                self._NL_()
            self._error('no available options')

        self.ast._define(
            ['id', 'mode', 'protocol', 'source', 'dest', 'icmp', 'options'],
            []
        )

    @graken()
    def _access_list_ip_extended_(self):
        with self._choice():
            with self._option():

                def block1():
                    self._access_list_remark_()
                self._positive_closure(block1)

                self.ast['remark'] = self.last_node
                with self._choice():
                    with self._option():
                        self._token('access-list')
                        self._access_list_ip_extended_id_()
                        self.ast['id'] = self.last_node
                        self._acl_mode_()
                        self.ast['mode'] = self.last_node
                        self._protocol_icmp_()
                        self.ast['protocol'] = self.last_node
                        self._acl_icmp_node_()
                        self.ast['source'] = self.last_node
                        self._acl_icmp_node_()
                        self.ast['dest'] = self.last_node
                        self._acl_icmp_options_()
                        self.ast['icmp'] = self.last_node
                        self._ip_access_list_extended_rule_options_()
                        self.ast['options'] = self.last_node
                        self._NL_()
                    with self._option():
                        self._token('access-list')
                        self._access_list_ip_extended_id_()
                        self.ast['id'] = self.last_node
                        self._acl_mode_()
                        self.ast['mode'] = self.last_node
                        self._acl_protocol_()
                        self.ast['protocol'] = self.last_node
                        self._node_()
                        self.ast['source'] = self.last_node
                        self._node_()
                        self.ast['dest'] = self.last_node
                        self._ip_access_list_extended_rule_options_()
                        self.ast['options'] = self.last_node
                        self._NL_()
                    self._error('no available options')
            with self._option():
                with self._choice():
                    with self._option():
                        self._token('access-list')
                        self._access_list_ip_extended_id_()
                        self.ast['id'] = self.last_node
                        self._acl_mode_()
                        self.ast['mode'] = self.last_node
                        self._protocol_icmp_()
                        self.ast['protocol'] = self.last_node
                        self._acl_icmp_node_()
                        self.ast['source'] = self.last_node
                        self._acl_icmp_node_()
                        self.ast['dest'] = self.last_node
                        self._acl_icmp_options_()
                        self.ast['icmp'] = self.last_node
                        self._ip_access_list_extended_rule_options_()
                        self.ast['options'] = self.last_node
                        self._NL_()
                    with self._option():
                        self._token('access-list')
                        self._access_list_ip_extended_id_()
                        self.ast['id'] = self.last_node
                        self._acl_mode_()
                        self.ast['mode'] = self.last_node
                        self._acl_protocol_()
                        self.ast['protocol'] = self.last_node
                        self._node_()
                        self.ast['source'] = self.last_node
                        self._node_()
                        self.ast['dest'] = self.last_node
                        self._ip_access_list_extended_rule_options_()
                        self.ast['options'] = self.last_node
                        self._NL_()
                    self._error('no available options')
            self._error('no available options')

        self.ast._define(
            ['remark', 'id', 'mode', 'protocol', 'source', 'dest', 'icmp', 'options'],
            []
        )

    @graken()
    def _access_list_ip_standard_id_(self):
        with self._choice():
            with self._option():
                self._pattern(r'[1-9][0-9]?')
            with self._option():
                self._pattern(r'13[0-9][0-9]?')
            self._error('expecting one of: 13[0-9][0-9]? [1-9][0-9]?')

    @graken()
    def _access_list_ip_extended_id_(self):
        with self._choice():
            with self._option():
                self._pattern(r'1[0-9][0-9]')
            with self._option():
                self._pattern(r'2[0-6][0-9][0-9]')
            self._error('expecting one of: 1[0-9][0-9] 2[0-6][0-9][0-9]')

    @graken()
    def _ignored_(self):
        with self._choice():
            with self._option():
                self._token('!')
                self._TOEOL_()
                self._NL_()
            with self._option():
                self._token(':')
                self._TOEOL_()
                self._NL_()
            with self._option():
                self._token('service')
                self._TOEOL_()
                self._NL_()
            with self._option():
                self._token('boot')
                self._TOEOL_()
                self._NL_()
            with self._option():
                with self._group():
                    with self._choice():
                        with self._option():
                            self._token('boot-start-marker')
                        with self._option():
                            self._token('boot-end-marker')
                        self._error('expecting one of: boot-end-marker boot-start-marker')
                self._NL_()
            with self._option():
                self._token('logging')
                self._TOEOL_()
                self._NL_()
            with self._option():
                self._token('no')
                self._TOEOL_()
                self._NL_()
            with self._option():
                self._token('clock')
                self._TOEOL_()
                self._NL_()
            with self._option():
                self._token('Current configuration')
                self._TOEOL_()
                self._NL_()
            with self._option():
                self._token('enable')
                self._TOEOL_()
                self._NL_()
            with self._option():
                self._token('resource')
                self._TOEOL_()
                self._NL_()
            with self._option():
                self._token('crypto')
                self._TOEOL_()
                self._NL_()

                def block1():
                    self._pattern(r'^ [^\n]*')
                    self._NL_()
                self._closure(block1)
                with self._optional():
                    self._token('!')
            with self._option():
                self._token('dot11')
                self._TOEOL_()
                self._NL_()

                def block2():
                    self._pattern(r'^ [^\n]*')
                    self._NL_()
                self._closure(block2)
                with self._optional():
                    self._token('!')
            with self._option():
                self._token('appfw')
                self._TOEOL_()
                self._NL_()

                def block3():
                    self._pattern(r'^ [^\n]*')
                    self._NL_()
                self._closure(block3)
                with self._optional():
                    self._token('!')
            with self._option():
                self._token('archive')
                self._TOEOL_()
                self._NL_()

                def block4():
                    self._pattern(r'^ [^\n]*')
                    self._NL_()
                self._closure(block4)
                with self._optional():
                    self._token('!')
            with self._option():
                self._token('route-map')
                self._TOEOL_()
                self._NL_()

                def block5():
                    self._pattern(r'^ [^\n]*')
                    self._NL_()
                self._closure(block5)
                with self._optional():
                    self._token('!')
            with self._option():
                self._token('vpdn')
                self._TOEOL_()
                self._NL_()

                def block6():
                    self._pattern(r'^ [^\n]*')
                    self._NL_()
                self._closure(block6)
                with self._optional():
                    self._token('!')
            with self._option():
                self._token('key')
                self._TOEOL_()
                self._NL_()

                def block7():
                    self._pattern(r'^ [^\n]*')
                    self._NL_()
                self._closure(block7)
                with self._optional():
                    self._token('!')
            with self._option():
                self._token('redundancy')
                self._TOEOL_()
                self._NL_()

                def block8():
                    self._pattern(r'^ [^\n]*')
                    self._NL_()
                self._closure(block8)
                with self._optional():
                    self._token('!')
            with self._option():
                self._token('username')
                self._TOEOL_()
                self._NL_()
            with self._option():
                self._token('bridge')
                self._TOEOL_()
                self._NL_()
            with self._option():
                self._token('encryption')
                self._TOEOL_()
                self._NL_()
            with self._option():
                self._token('control-plane')
                self._NL_()
            with self._option():
                self._token('banner')
                self._TOEOL_()
                self._NL_()

                def block9():
                    self._pattern(r'^ [^\n]*')
                    self._NL_()
                self._closure(block9)
                with self._optional():
                    self._token('!')
                    self._NL_()
            with self._option():
                self._token('Using')
                self._int_()
                self._token('out of')
                self._int_()
                self._token('bytes')
                self._NL_()
            with self._option():
                self._token('aaa')
                self._TOEOL_()
                self._NL_()
            with self._option():
                self._token('multilink')
                self._TOEOL_()
                self._NL_()
            with self._option():
                self._token('snmp-server')
                self._TOEOL_()
                self._NL_()
            with self._option():
                self._token('security')
                self._TOEOL_()
                self._NL_()
            with self._option():
                self._token('mmi')
                self._TOEOL_()
                self._NL_()
            with self._option():
                self._token('isdn')
                self._TOEOL_()
                self._NL_()
                self._token('!')
                self._NL_()
            with self._option():
                self._token('dialer-list')
                self._TOEOL_()
                self._NL_()
            with self._option():
                self._token('router')
                self._TOEOL_()
                self._NL_()

                def block10():
                    self._pattern(r'^ [^\n]*')
                    self._NL_()
                self._closure(block10)
                with self._optional():
                    self._token('!')
            with self._option():
                self._token('arp')
                self._TOEOL_()
                self._NL_()
            with self._option():
                self._token('snmp')
                self._TOEOL_()
                self._NL_()
            with self._option():
                self._token('rmon')
                self._TOEOL_()
                self._NL_()
            with self._option():
                self._token('dial-peer')
                self._TOEOL_()
                self._NL_()
            with self._option():
                self._token('rtr')
                self._TOEOL_()
                self._NL_()
            with self._option():
                self._token('alias')
                self._TOEOL_()
                self._NL_()
            with self._option():
                self._NL_()
            self._error('no available options')

    @graken()
    def _ip_ignored_(self):
        with self._choice():
            with self._option():
                self._token('cef')
                self._NL_()
            with self._option():
                self._token('inspect')
                self._TOEOL_()
                self._NL_()
            with self._option():
                self._token('domain')
                self._TOEOL_()
                self._NL_()
            with self._option():
                self._token('name-server')
                self._TOEOL_()
                self._NL_()
            with self._option():
                self._token('route')
                self._TOEOL_()
                self._NL_()
            with self._option():
                self._token('http')
                self._TOEOL_()
                self._NL_()
            with self._option():
                self._token('nat')
                self._TOEOL_()
                self._NL_()
            with self._option():
                self._token('subnet-zero')
                self._NL_()
            with self._option():
                self._token('dhcp excluded-address')
                self._TOEOL_()
                self._NL_()
            with self._option():
                self._token('dhcp pool')

                def block0():
                    self._pattern(r'[^(!|\n)]*')
                    self._NL_()
                self._closure(block0)
                self._token('!')
                self._NL_()
            with self._option():
                self._token('tcp')
                self._TOEOL_()
                self._NL_()
            with self._option():
                self._token('ssh')
                self._TOEOL_()
                self._NL_()
            with self._option():
                self._token('classless')
                self._NL_()
            with self._option():
                self._token('forward-protocol')
                self._TOEOL_()
                self._NL_()
            with self._option():
                self._token('ips')
                self._TOEOL_()
                self._NL_()
            with self._option():
                self._token('flow-cache')
                self._TOEOL_()
                self._NL_()
            with self._option():
                self._token('flow-export')
                self._TOEOL_()
                self._NL_()
            with self._option():
                self._token('vrf')
                self._TOEOL_()
                self._NL_()

                def block1():
                    self._pattern(r'^ [^\n]*')
                    self._NL_()
                self._closure(block1)
                with self._optional():
                    self._token('!')
            with self._option():
                self._token('multicast-routing')
                self._TOEOL_()
                self._NL_()
            with self._option():
                self._token('accounting-threshold')
                self._TOEOL_()
                self._NL_()
            self._error('no available options')


class iosSemantics(object):
    def ip4(self, ast):
        return ast

    def ipX(self, ast):
        return ast

    def ip6(self, ast):
        return ast

    def NL(self, ast):
        return ast

    def TOEOL(self, ast):
        return ast

    def identifier(self, ast):
        return ast

    def int(self, ast):
        return ast

    def string(self, ast):
        return ast

    def obj_name(self, ast):
        return ast

    def hostname(self, ast):
        return ast

    def domain_name(self, ast):
        return ast

    def description(self, ast):
        return ast

    def interface(self, ast):
        return ast

    def interface_alias(self, ast):
        return ast

    def interface_detail(self, ast):
        return ast

    def acl_id(self, ast):
        return ast

    def acl_line(self, ast):
        return ast

    def acl_extended(self, ast):
        return ast

    def acl_mode(self, ast):
        return ast

    def acl_protocol(self, ast):
        return ast

    def node(self, ast):
        return ast

    def acl_object_group_network_id(self, ast):
        return ast

    def acl_object_network_id(self, ast):
        return ast

    def acl_object_group_service_id(self, ast):
        return ast

    def acl_object_service_id(self, ast):
        return ast

    def acl_object_group_icmp_id(self, ast):
        return ast

    def acl_object_group_protocol_id(self, ast):
        return ast

    def acl_names_id(self, ast):
        return ast

    def acl_time_range_id(self, ast):
        return ast

    def acl_host(self, ast):
        return ast

    def acl_port(self, ast):
        return ast

    def acl_icmp_options(self, ast):
        return ast

    def acl_options(self, ast):
        return ast

    def acl_option(self, ast):
        return ast

    def acl_option_log_option(self, ast):
        return ast

    def acl_icmp_node(self, ast):
        return ast

    def remark(self, ast):
        return ast

    def object(self, ast):
        return ast

    def object_type(self, ast):
        return ast

    def network_object(self, ast):
        return ast

    def service_object(self, ast):
        return ast

    def service_object_op(self, ast):
        return ast

    def service_object_source(self, ast):
        return ast

    def service_object_destination(self, ast):
        return ast

    def object_group(self, ast):
        return ast

    def protocol_icmp(self, ast):
        return ast

    def protocol(self, ast):
        return ast

    def port_group_protocol(self, ast):
        return ast

    def object_group_type(self, ast):
        return ast

    def service_group_object(self, ast):
        return ast

    def port_group_object(self, ast):
        return ast

    def network_group_object(self, ast):
        return ast

    def icmp_group_object(self, ast):
        return ast

    def protocol_group_object(self, ast):
        return ast

    def port(self, ast):
        return ast

    def hour(self, ast):
        return ast

    def minute(self, ast):
        return ast

    def time(self, ast):
        return ast

    def year(self, ast):
        return ast

    def day(self, ast):
        return ast

    def date(self, ast):
        return ast

    def timedate(self, ast):
        return ast

    def time_range_object(self, ast):
        return ast

    def time_range(self, ast):
        return ast

    def day_of_the_week(self, ast):
        return ast

    def month(self, ast):
        return ast

    def icmp_type(self, ast):
        return ast

    def protocol_code(self, ast):
        return ast

    def port_code(self, ast):
        return ast

    def grammar(self, ast):
        return ast

    def version(self, ast):
        return ast

    def command(self, ast):
        return ast

    def ip(self, ast):
        return ast

    def ip_command(self, ast):
        return ast

    def ip_access_list(self, ast):
        return ast

    def ip_access_list_standard_rule_option(self, ast):
        return ast

    def ip_access_list_standard_rule_options(self, ast):
        return ast

    def ip_access_list_remark(self, ast):
        return ast

    def ip_access_list_standard_rule(self, ast):
        return ast

    def ios_host(self, ast):
        return ast

    def ios_node(self, ast):
        return ast

    def ip_access_list_standard(self, ast):
        return ast

    def ip_access_list_extended_rule_option(self, ast):
        return ast

    def ip_access_list_extended_rule_options(self, ast):
        return ast

    def ip_access_list_extended_rule(self, ast):
        return ast

    def ip_access_list_extended(self, ast):
        return ast

    def host_wildcard(self, ast):
        return ast

    def access_list_ip_standard_rule(self, ast):
        return ast

    def access_list_ip_standard(self, ast):
        return ast

    def access_list_remark(self, ast):
        return ast

    def access_list(self, ast):
        return ast

    def access_list_ip_extended_rule(self, ast):
        return ast

    def access_list_ip_extended(self, ast):
        return ast

    def access_list_ip_standard_id(self, ast):
        return ast

    def access_list_ip_extended_id(self, ast):
        return ast

    def ignored(self, ast):
        return ast

    def ip_ignored(self, ast):
        return ast


def main(filename, startrule, trace=False, whitespace=None, nameguard=None):
    import json
    with open(filename) as f:
        text = f.read()
    parser = iosParser(parseinfo=False)
    ast = parser.parse(
        text,
        startrule,
        filename=filename,
        trace=trace,
        whitespace=whitespace,
        nameguard=nameguard)
    print('AST:')
    print(ast)
    print()
    print('JSON:')
    print(json.dumps(ast, indent=2))
    print()

if __name__ == '__main__':
    import argparse
    import string
    import sys

    class ListRules(argparse.Action):
        def __call__(self, parser, namespace, values, option_string):
            print('Rules:')
            for r in iosParser.rule_list():
                print(r)
            print()
            sys.exit(0)

    parser = argparse.ArgumentParser(description="Simple parser for ios.")
    parser.add_argument('-l', '--list', action=ListRules, nargs=0,
                        help="list all rules and exit")
    parser.add_argument('-n', '--no-nameguard', action='store_true',
                        dest='no_nameguard',
                        help="disable the 'nameguard' feature")
    parser.add_argument('-t', '--trace', action='store_true',
                        help="output trace information")
    parser.add_argument('-w', '--whitespace', type=str, default=string.whitespace,
                        help="whitespace specification")
    parser.add_argument('file', metavar="FILE", help="the input file to parse")
    parser.add_argument('startrule', metavar="STARTRULE",
                        help="the start rule for parsing")
    args = parser.parse_args()

    main(
        args.file,
        args.startrule,
        trace=args.trace,
        whitespace=args.whitespace,
        nameguard=not args.no_nameguard
    )
